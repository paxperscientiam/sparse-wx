//declare var Logger: {log: (...x) => string}

// https://github.com/Microsoft/TypeScript/issues/17340#issuecomment-316984951
// interface IData {
//   id: string
//   [propName: string]: any
// }

export class Model  {
  /*
   * Returns instance with properties assigned at instantiation
   *
   * @param data - Property object passed at time of instantiation
   */

  _accumulator
  _data
  _ns
  _properties

  _cache
  //
  fields
  _fields

  _updatedKeys = []

  constructor(data = {id: null}, fields = {}, cache = undefined) {
    this._cache = cache
    this._accumulator = []
    this._data = { id: data.id }
    this._fields = fields
    this.fields = fields
    this._ns = data.id

    const tempData = {}

    let dataKeys = Object.keys(data)
    const fieldKeys = Object.keys(fields)

    void ((obj1, obj2) => {
      dataKeys.map((key) => {
        if (obj2.hasOwnProperty(key) &&
            obj2[key] === this._ns + key) {
          tempData[key] = data[key]
        }
      })
    })(data, fields)

    // cleaned up data
    this._data = {...this._data, ...tempData }
    dataKeys = Object.keys(this._data)

    fieldKeys.map((fk) => {
      if (this._fields[fk] === this._ns + fk) {
        this._accumulator.push(fk)
        let datum = this._data[fk]
        if (datum === null ||
            datum === void(0) ||
            datum === typeof(undefined)) {
          datum = undefined
        } else {
          datum = datum.toString()
        }
        if (this._cache) {
          this._cache.setProperty(this._fields[fk], datum)
        }
        this._data[fk] = datum
        //
        Object.defineProperty(this, fk, {
          get: () => {
            if (this._data[fk] === null ||
                this._data[fk] === void(0) ||
                this._data[fk] === typeof(undefined)) {
              if (this._cache) {
                return this._cache.getProperty(this._fields[fk])
              }
            }
            return this._data[fk]
          },
          set: (value) => {
            let stored
            if (this._cache) {
              stored = this._cache.getProperty(this._fields[fk])
            }
            if (stored !== value) {
              this._updatedKeys.push(fk)
            }
            if (value === null ||
                value === void(0) ||
                value === typeof(undefined)) {
              value = undefined
            } else {
              value = value.toString()
            }
            if (this._cache) {
              this._cache.setProperty(this._fields[fk], value)
            }
            this._data[fk] = value
          },
        })
      }
    })
    Object.freeze(this)
  }
}
//
function getAllMethods(obj) {
  return Object.getOwnPropertyNames(obj)
               .filter((prop) => {
                 return typeof obj[prop] === "function"
               })
}

function userStateTest() {
  // I think this is working!
  clearConfig()

  var props = {
    address: "user_address",
    city: "user_city",
    name: "user_name",
    state: "user_state",
    country: "user_country",
    age: "user_age",
  };
  var cache = PropertiesService.getUserProperties();
  var U = (new Model({ id: "user_", address: "barf street", city: "yongers" }, props, cache));

  U.city = "fuck you!";
  U.name = "Marcus";
  U.cockface = "big cocks";

  Logger.log(U.fields)
  return U.fields
}
